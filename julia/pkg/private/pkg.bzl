"""Bazel tools for interfacing with Julia packages"""

load("@bazel_tools//tools/build_defs/repo:http.bzl", "http_archive")

_HUB_BUILD_FILE = """\
\"\"\"Autogenerated by rules_julia.\"\"\"

load("@rules_julia//julia:julia_library.bzl", "julia_library")

PACKAGES = {packages}

julia_library(
    name = "{name}",
    srcs = [],
    deps = [
        "@{name}__" + pkg
        for pkg in PACKAGES
    ],
    visibility = ["//visibility:public"],
)

[
    alias(
        name = pkg,
        actual = "@{name}__" + pkg,
        visibility = ["//visibility:public"],
    )
    for pkg in PACKAGES
]
"""

_PKG_BUILD_FILE = """\
\"\"\"Autogenerated by rules_julia.\"\"\"

load("@rules_julia//julia:julia_library.bzl", "julia_library")

DEPENDENCIES = {dependencies}

julia_library(
    name = "{name}",
    srcs = glob(
        include = [
            "src/**/*.jl",
            "ext/**/*.jl",
        ],
        allow_empty = True,
    ),
    data = glob(
        include = [
            "*.toml",
            "src/**",
            "ext/**",
        ],
        exclude = [
            "src/**/*.jl",
            "ext/**/*.jl",
        ],
        allow_empty = True,
    ),
    deps = [
        "@{hub_name}__" + dep
        for dep in DEPENDENCIES
    ],
    tags = [
        "julia_pkg_version={version}",
        "julia_pkg_uuid={uuid}",
    ],
    visibility = ["//visibility:public"],
)

alias(
    name = "{repo_name}",
    actual = "{name}",
    visibility = ["//visibility:public"],
)
"""

def _pkg_hub_impl(repository_ctx):
    repository_ctx.file("WORKSPACE.bazel", """workspace(name = "{}")""".format(
        repository_ctx.name,
    ))

    repository_ctx.file("BUILD.bazel", _HUB_BUILD_FILE.format(
        name = repository_ctx.attr.hub_name,
        packages = json.encode_indent(repository_ctx.attr.packages, indent = " " * 4),
    ))

pkg_hub = repository_rule(
    implementation = _pkg_hub_impl,
    attrs = {
        "hub_name": attr.string(
            mandatory = True,
        ),
        "packages": attr.string_list(
            mandatory = True,
        ),
    },
)

def _read_lockfile_json(module_ctx, lockfile_path):
    """Read and parse the Manifest.bazel.json lockfile.

    Returns a dictionary mapping package names to package data including SHA256 hashes.
    """
    lockfile = module_ctx.path(lockfile_path)
    module_ctx.watch(lockfile)
    content = module_ctx.read(lockfile)

    # Parse JSON content
    packages = json.decode(content)

    return packages

def install(*, module_ctx, attrs, annotations = {}):
    """Instantiate the pkg module for the given `install` tag_class attributes.

    Args:
        module_ctx (module_ctx): The current module context.
        attrs (struct): The attributes from the `install` tag class.
        annotations (dict): Optional dictionary mapping package names to annotation data.

    Returns:
        str: The name of the hub repository for the current tag_class.
    """

    # Read the JSON lockfile
    packages = _read_lockfile_json(module_ctx, attrs.lockfile)

    # Get all package names for dependency filtering
    all_package_names = set(packages.keys())

    # Create repositories for all packages
    for package_name, package_data in packages.items():
        # Extract package information
        urls = package_data.get("urls", [])
        version = package_data.get("version", "")
        uuid = package_data.get("uuid", "")
        all_deps = package_data.get("deps", [])

        # Validate required fields
        if not urls:
            fail("Package {} missing URLs in lockfile".format(package_name))
        if not uuid:
            fail("Package {} missing UUID in lockfile".format(package_name))

        # Filter dependencies to only include packages in this lockfile
        deps = [dep for dep in all_deps if dep in all_package_names]

        repo_name = "{}__{}".format(attrs.name, package_name)

        # Get annotations for this package if any
        package_annotations = annotations.get(package_name)

        # Build http_archive arguments
        http_archive_args = {
            "build_file_content": _PKG_BUILD_FILE.format(
                name = package_name,
                dependencies = deps,
                hub_name = attrs.name,
                repo_name = repo_name,
                version = version,
                uuid = uuid,
            ),
            "integrity": package_data.get("integrity", ""),
            "name": repo_name,
            "sha256": package_data.get("sha256", ""),
            "type": "tar.gz",
            "urls": urls,
        }

        # Apply patch-related attributes if annotations exist for this package
        if package_annotations:
            if "patches" in package_annotations:
                http_archive_args["patches"] = package_annotations["patches"]
            if "patch_args" in package_annotations:
                http_archive_args["patch_args"] = package_annotations["patch_args"]
            if "patch_tool" in package_annotations:
                http_archive_args["patch_tool"] = package_annotations["patch_tool"]

        # Use julia_pkg repository rule with SHA256 verification from lockfile
        http_archive(**http_archive_args)

    # Create hub with all packages
    pkg_hub(
        name = attrs.name,
        hub_name = attrs.name,
        packages = list(packages.keys()),
    )

    return attrs.name
